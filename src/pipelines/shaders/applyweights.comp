#version 450
layout(set = 0, binding = 0) uniform UniformBuffer {
    uint input_size;
    uint output_size;
    uint batch_size;
};

layout(set = 0, binding = 1) buffer NetworkWeights {
    float[] network_weights;
};

layout(set = 0, binding = 2) buffer InputData {
    float[] input_data;
};

layout(set = 0, binding = 3) buffer Target {
    float[] target;
};

float dot_product(uint index_of_output_vector, uint index_in_output_vector) {
    float accumulator = 0;
    //network_weights: ^input_size, _output_size
    //input_data: _input_size, _batch_size
    //Contracting along input_size
    for(uint contraction_index = 0; contraction_index < input_size; contraction_index++) {
        accumulator += network_weights[index_in_output_vector * input_size + contraction_index] * input_data[index_of_output_vector * input_size + contraction_index];
    }
    return accumulator;
}

void main() {
    uint index_of_output_vector = gl_GlobalInvocationID.x;
    //Number of output vectors is batch_size
    uint index_in_output_vector = gl_GlobalInvocationID.y;
    //Size of output vectors is output_size
    target[index_of_output_vector * output_size + index_in_output_vector] = dot_product(index_of_output_vector, index_in_output_vector);
    //Target: _output_size, _batch_size
}
