#version 450
layout(set = 0, binding = 0) uniform UniformBuffer {
    uint input_size;
    uint output_size;
    uint batch_size;
};

layout(set = 0, binding = 1) buffer NetworkWeights {
    float[] network_weights;
};

layout(set = 0, binding = 2) buffer InputData {
    float[] input_data;
};

layout(set = 0, binding = 3) buffer IntermediateData {
    float[] intermediate_data;
};

layout(set = 0, binding = 4) buffer LabelDifference {
    float[] label_difference;
};

layout(set = 1, binding = 0) buffer Target {
    float[] target;
};

float learning_rate = 0.1;

float LReluPrime(float x) {
    float OffZeroGrads = (x > 0.0) ? 1.0 : 0.1;
    return (x == 0.0) ? 0.55 : OffZeroGrads;
}

float grad(uint index_collumn, uint index_row){
    float accumulator = 0;
    for(uint contraction_index = 0; contraction_index < batch_size; contraction_index++){
        accumulator += label_difference[contraction_index * output_size + index_collumn] * input_data[contraction_index * input_size + index_row];
    }
    return accumulator;
}

void main() {
    uint collumn_index = gl_GlobalInvocationID.x;
    uint row_index = gl_GlobalInvocationID.y;
    float gradient = grad(collumn_index, row_index);
    target[collumn_index * input_size + row_index] = network_weights[row_index * output_size + collumn_index] - learning_rate * gradient;
}
